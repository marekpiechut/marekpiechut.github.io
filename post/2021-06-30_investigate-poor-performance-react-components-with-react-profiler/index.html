<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Investigate poor performance React components with “React Profiler” | rand(4) Thoughts</title>
<meta name=keywords content><meta name=description content="This post is a work in progress chapter from “React Performance” book i’ve started working on and haven’t touched for few months. Looks like it will never be released, so I’ll just post parts that I think might be useful as blog posts._You’re probably here, because you already know that something is wrong with a part of your application. Maybe after some change, maybe when hit with a big dataset, your component/screen started to get slow."><meta name=author content="Marek Piechut"><link rel=canonical href=https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://marekpiechut.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://marekpiechut.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://marekpiechut.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://marekpiechut.github.io/apple-touch-icon.png><link rel=mask-icon href=https://marekpiechut.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=marekpiechut.github.io src=https://insights.dayone.pl/js/script.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><style>body{font-family:inter,sans-serif;font-optical-sizing:auto;font-size:16px;font-style:normal;letter-spacing:-.3px;--theme:#f4f4f4}h1,h2,h3,h4,h5,h6,.entry-link,.logo{font-family:montserrat,sans-serif;font-optical-sizing:auto;font-style:normal}</style><meta property="og:title" content="Investigate poor performance React components with “React Profiler”"><meta property="og:description" content="This post is a work in progress chapter from “React Performance” book i’ve started working on and haven’t touched for few months. Looks like it will never be released, so I’ll just post parts that I think might be useful as blog posts._You’re probably here, because you already know that something is wrong with a part of your application. Maybe after some change, maybe when hit with a big dataset, your component/screen started to get slow."><meta property="og:type" content="article"><meta property="og:url" content="https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/"><meta property="og:image" content="https://marekpiechut.github.io/images/1.jpeg"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-06-30T06:32:56+00:00"><meta property="article:modified_time" content="2024-06-30T12:44:09+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://marekpiechut.github.io/images/1.jpeg"><meta name=twitter:title content="Investigate poor performance React components with “React Profiler”"><meta name=twitter:description content="This post is a work in progress chapter from “React Performance” book i’ve started working on and haven’t touched for few months. Looks like it will never be released, so I’ll just post parts that I think might be useful as blog posts._You’re probably here, because you already know that something is wrong with a part of your application. Maybe after some change, maybe when hit with a big dataset, your component/screen started to get slow."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://marekpiechut.github.io/post/"},{"@type":"ListItem","position":2,"name":"Investigate poor performance React components with “React Profiler”","item":"https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Investigate poor performance React components with “React Profiler”","name":"Investigate poor performance React components with “React Profiler”","description":"This post is a work in progress chapter from “React Performance” book i’ve started working on and haven’t touched for few months. Looks like it will never be released, so I’ll just post parts that I think might be useful as blog posts._You’re probably here, because you already know that something is wrong with a part of your application. Maybe after some change, maybe when hit with a big dataset, your component/screen started to get slow.","keywords":[],"articleBody":"This post is a work in progress chapter from “React Performance” book i’ve started working on and haven’t touched for few months. Looks like it will never be released, so I’ll just post parts that I think might be useful as blog posts._You’re probably here, because you already know that something is wrong with a part of your application. Maybe after some change, maybe when hit with a big dataset, your component/screen started to get slow. You probably can see it when you invoke some action, that UI is no longer responsive and you’re pretty sure it’s React rendering that takes too long.\nYou’re already thinking about adding some useCallback, useMemo, and React.memo calls, but where? Sometimes it\"s obvious. Component structure is simple and you have the gut feeling what might be causing the problem. But sometimes you just stare at the code and have no idea where, in this huge component tree, we\"re dropping these frames. Which component to wrap with memo or which callback is responsible for component re-rendering regardless of nothing changing in it\"s data.\nQuick Win In this section we’ll try to answer exactly that — how to find that one component (or group of components) that is causing the slowdown.\nLet’s start with quickest way we can get to the answer. React already has some nice tools that will help us out. We’ll dive into React Profiler and without much introduction just try to hunt the performance hog.\nInstall React Profiler —\n🤔 Feel free to skip this section if you already have it installed.\n—\nReact profiler is a part of totally awesome React Developer Tools package available for Chrome/Chromium and Firefox. You can download it here:\nChrome: https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi Firefox: https://addons.mozilla.org/en-US/firefox/addon/react-devtools/ Both are being developed by core React team and built from the same codebase, so they should provide the same functionality. So it shouldn’t matter which one you use. Just select browser you’re most comfortable to work with. Unfortunately there’s no support for other tools as of now. You’ll have to use standalone edition if you need to debug/profile these (we’ll dive into that later on).\nAfter installation you should be able to access React profiler inside your browser developer tools (we’re looking for the Components and Profiler tabs):\nWhen you have it all and running open your application in the browser, navigate to Profiler tab and start profiling (Press blue circle button in the top left corner). Click around your app for few seconds and stop it by pressing red circle button . If you didn\"t get any errors we should be all set and ready to dive into it.\n—\n⚠️ I’m getting “Profiling not supported.” message, what next? — make sure you’re running your React app in development mode. Profiling is disabled by default on production builds. Don’t worry for now. Will handle it later. Just switch to development mode. Most of the performance issues will be visible in both — production and development builds anyways.\n—\nInvestigate slow page Now that we have our profiler running we can go on and try to investigate some slowly loading page in your app. We’ll be investigating a lazy loaded list of old notifications. We expect it to be doing more work than required when each load is finished, but we encourage you to open up application you’re currently developing and check a page that you think might need some performance improvements and it’s not related to network time.\nSo let’s dit into it. As always we start with a clean state to make sure we’re touching only code we think we do and that nothing is going to skew our measurements, so:\n✔️ Checkout to a commit you want to profile or stage your current changes\n✔️ Make sure theres not much going on on your machine. CPU or memory hungry applications might skew our results.\nAnd here’s the screen we’ll be working on:\nIt’s currently showing the last 20 notifications, but we have many more on the backend and whenever you’re near the bottom we’ll be fetching new ones and appending to the list. Just classic lazy loading infinite (Of course it’s not infinite, we’ll run out of notifications in few screens, but it has enough to make it interesting) scroll.\nWhat we need to do now, after initial rendering of the page is done, is to gather a profiler baseline, so we know if we’re fixing performance or making it worse. Let’s open React Profiler, start recording and scroll down until we hit the lazy load boundary few times, at least twice. Then immediately stop the profiling session. Output should be similar to what you see on the screenshot below.\nThat’s a lot of output, but we’re not really interested in all of that. We start by investigating the commits chart at the top:\nWhat we can see here, is that we had 20 “commits” — 20 times React has applied changes to the browser DOM. That’s not bad actually when we think about all the loading state changes and that we’ve executed lazy loads few times. What is more interesting though, is that this chart is constantly moving up, so it looks like we’re doing more and more work on each commit. When you hover over the bars, you’ll also see, that we get from around 90ms to almost 200ms time for single render. This is probably now what we were expecting. We are fetching 20 items in each batch and appending them to the list. Of course we’re doing some more work when going through ever-growing list of items, but we should only append new 20 nodes to the DOM tree. It looks suspicious, let’s dig into it a little bit more.\nTo do that, we start at the last commit and check what was rendered there.\nWe can ignore all the grey bars — these components did not change during this render. First interesting one is the Notifications component. It did render, and that\"s expected. We have changed its state, so this looks fine. We also see, that commit of Notifications component itself did not take a lot of time. It\"s only 3.5ms. But take a look on all these small components at the bottom. All of them are colored, so they all have changed and their DOM changes were applied. Compare them to the previous screen. We see that in each commit there\"s more and more of these, and all of them are always rendered. If you hover over them, you\"ll see, that they are the individual notifications.\nAlso, if you did not refresh the page or change page structure, React Profiler will highlight actual nodes that were rendered during the commit. Scrolling to the top of the page and hovering over one of the first nodes in the flame chart will reveal the truth. We’re re-rendering every notification on each update.\nThis makes no sense. These components will never change. We only append new notifications at the end. There’s no way data can change and they should not trigger any DOM updates. It looks like we’ve found good place to try out React.memo. Let\"s wrap our NotificationItem into it and see if it helps.\nMemoize Component Digging into the source code it looks like we’re using just a regular functional component for a single notification item. Usually that’s totally fine and in most cases should not matter. But here we’re rendering quite a lot of them and it makes sense to give it few minutes of thought and try to memoize rendered component. Here’s how it look like right now. Actual body of the component does not matter, it’s only important that it is a functional component and that it’s not memoized yet. const NotificationItem = ({ notification, onMarkAsRead, session }: Props) =\u003e ...\nOk, let’s wrap it up with React.memo and see if it helps:\nconst NotificationItem = React.memo\u003cProps\u003e( ({ notification, onMmarkAsRead, session }) =\u003e \u003cdiv\u003e...\u003c/div\u003e ) Now rebuild project, and start a new profiling session. Make sure that you have similar environment (nothing heavy is running on your computer and you gave few seconds for VM to warm up). And check if our fix has helped to mitigate the problem:\nYup, looks like the problem is fixed. In the commits bar we can see a “rake” pattern. Lower bar being a render of loading indicator, when no notification change, and higher bar being actual rendering of newly fetched data. Also each render takes similar time now — around 60–70ms and looking at the flame chart at the bottom we see, that previously fetched notifications are not re-rendered (they are greyed out).\nWrap Up Looks like we have fixed our problem and here we have our quick win. It was enough to simply wrap a component with React.memo. But what\"s more important here is that we\"ve made an informed change. There was no guesswork about where the problem is. We had hard evidence, that there was unnecessary work being done and then we have fixed it.\n—\n⚠️ There’s some more consideration needed when using React.memo. Sometimes adding it adds more overhead instead of fixing the problem. It might be the case, that it won’t help in your project.\n—\nDeep dive React Profiler is a nice tool to quickly investigate possible performance issues in rendering process. In this chapter we’ll be doing a deep dive into how it works and what actually it measures. We’ll also take a look at React APIs that are used internally by the profiler and investigate how we might use it ourselves to get more answers than React Profiler provides.\nProfiler UI Let’s take a detailed look into information available in React Profiler and how it’s presented. To have a better image of what is going on here, we need to remember about 2 stages of React rendering process:\nFirst stage called Render or Reconciliation is one that calls all render functions on components, generates a Virtual DOM and compares it to the previous vDOM. This way it knows which nodes have changed and need to be applied to the browser DOM. Second stage — Commit — responsible for doing actual changes on browser DOM. This has to be done in single call to the browser APIs and will be done in “stop the world” manner. If we would allow it to be done in stages or in background, user would see intermediate stages while we are updating the UI. With that in mind we can now take a look at the commits view in the profiler. It’s this small bar chart at the top:\nWhat we see here is a list of all commits that React has flushed to DOM during our profiling session. Each bar is showing a separate commit in sequence of execution. Although it shows commits, it does count the render phase. You can test it out using this simple code:\nimport { useState } from \"react\" const SlowComponent = ({ noSlowdown }) =\u003e { const arr = [] if (!noSlowdown) { for (var i = 1000000 - 1; i \u003e= 0; i--) { arr.push(i) } } return \u003cdiv\u003eI\"m slooooooow } const FastComponent = () =\u003e { return I\"m fassssst....\u003c/div\u003e } const App = () =\u003e { const [dummy, setDummy] = useState() return ( \u003cdiv className=\"App\"\u003e \u003cSlowComponent noSlowdown={dummy % 2} /\u003e \u003cFastComponent /\u003e \u003cbutton onClick={() =\u003e setDummy(Date.now())}\u003eRender!\u003c/button\u003e \u003c/div\u003e ) } export default App Loading it and pressing Render! button few times shows that slow component is impacting profiling results regardless of it returning the same trivial single div. Commit cost of both components is exactly the same, yet profiling results are completely different: fast component renders nearly instantly while slow component takes 32ms out of 33ms total rendering time.\nTraveling back and fourth through the commits you can find some interesting patterns in render times that you didn’t expect. Selecting one of them will show you exact render duration and few more details about it.\nAs you have probably already noticed React Profiler marks commits and components with different colors and bar length. Generally the longer the bar and warmer the color (more yellow), the more time it took to render compared to other commits and components. Grey lines did not render at all during given run.\n—\n🤔 Note:\nLine length shows how long did it take for component to render with all it’s children Line color shows how long did component itself render compared to other components (how slow/fast it is) —\nThere are two more interesting views here: Flamegraph and Ranked tab. First shows all components in your view in a tree according to your components structure. Second orders components by their rendering time ( self render time — how long it took to render component excluding its children time). It’s very useful to catch slowest components — a good place to start searching for problems. Hovering on the bars will highlight it on the page and selecting one of them will show you history of commits of given components and reason why render was triggered (ex: state change, parent render, props change, etc.). This information is sometimes enough to get you on track with figuring out what’s wrong. Very often some props change, that we didn’t expect to be any different.\n—\n⚠️ It’s usually good idea to have “Record why each component rendered while profiling.” option enabled. It might add some overhead to profiling process, but it’s usually not a problem if your app is not super-huge. Just press the options cog ⚙️ and enable it now.\n—\nThere’s also an option to hide commits that took below given time. It’s not super useful, as we usually are looking for anomalies, and want to see whole picture. It’s better idea to narrow use case to short problematic interaction, but you might also start with longer recording sessions and try to find issues using this filter.\nReact Profiler API DevTools profiler allows to gain a lot of knowledge about performance issues in your app. But if what you need is to profile only selected component and do it in production, there’s also a React Profiler API (https://reactjs.org/docs/profiler.html). It’s a lightweight component to gather data about it render times, thus giving an insight of performance of its children.\nIt will not allow us to get a deep tree of render stats like we have in Profiler view in DevTools, but allows to programmatically get timings for selected components in the app. Usage is simple, just wrap your component and provide onRender callback:\n\u003cProfiler id=\"user-profile\" onRender={( id, phase, actualTime, baseTime, startTime, commitTime, interactions ) =\u003e aggregatePerformance(id, phase, actualDuration, interactions)} \u003e \u003cUserProfile user={user} /\u003e \u003c/Profiler\u003e We’ve got quite a few parameters to the callback, but except of that it looks pretty straightforward. Let’s go through all the data we have in the callback:\nid — this is exactly the same as what we have passed into the Profiler tag. React does nothing interesting with this parameter. It\"s not grouping or overriding profiler tags with same Id. You can have as many as you want with exactly same value. Its role is purely informational, so you can have single callback, reuse it between profilers and still know which measures you have received. phase — component lifecycle phase. This can only be: mount or update and means exactly what you expect. Can be used find out if problem is only appearing during mount - maybe some slow useEffect that is firing only on mount. actualTime — measured duration of rendering. This is a real time of render during given commit. If you’re using memoization this time should go down significantly. If it does not, then you might found the problem. baseTime — estimated time of full render of component subtree. This should roughly be the same time as the actualTime when component did mount if it did not do any heavy initialization. If you’re using memoization correctly, this time should be usually larger. startTime — simply a timestamp when rendering started commitTime — timestamp when rendering was finished. This time is shared between all profilers that took part in the commit. Thanks to that you can group data from separate sub-trees that were rendered due to same change in state. interactions — list of all interactions associated with this render. Profiler API is very simple and allows to track performance of our components even on production. Just keep in mind, that it has a cost associated. There’s a small performance penalty for each Profiler instance in your components tree. Also make sure you\"re not doing a lot of processing in your callback. It\"s best to do any calculations asynchronously, or just dump your data to server and do all heavy-lifting there.\nProfiling in production builds Due to small performance impact profiler API is disabled in production builds of React (as of May 2021). While it’s usually not a problem, as most of real performance issues will be visible in both production and development builds. Sometimes you want to dig into production bundle and gain some insights on rendering time.\nThe way it’s currently being disabled is through build time configuration. So if you have built your app with regular ReactDOM, you’ll have to re-build it. Here’s what to put in Webpack config to switch to profiling versions of libraries:\nmodule.exports = { //... resolve: { alias: { \"react-dom$\": \"react-dom/profiling\", \"scheduler/tracing\": \"scheduler/tracing-profiling\", } } }; In case you’re using create-react-app script, just add --profile flag during build process:\n# Using Yarn yarn build --profile # Using NPM npm run build -- --profile With all this in place profiling should work just fine in production build. Regardless of that we’re not really advising to add it to your build process. It should be enough to run this build locally and connecting it to production backend. It should be trivial if you’re already serving your app from CDN or static folder using your Web server.\nPerformance impact As we have already noticed, profiler builds tend to run slower. Even if you’re not actively profiling. We’ve done a quick benchmark to actually measure it:\nconst ROUNDS = 100_000 const Benchmark = () =\u003e { const [took, setTook] = useState() const [round, setRound] = useState(1) const start = useRef(performance.now())``useEffect(() =\u003e { if (round \u003c ROUNDS) { setRound(round + 1) } else { setTook(performance.now() - start.current) } }, [round])``return ( \u003cdiv className=\"App\"\u003e \u003cdiv\u003e{round}\u003c/div\u003e \u003cdiv\u003eTook: {took}ms\u003c/div\u003e \u003c/div\u003e ) } And results are:\nDevelopment: 13575ms\nProduction: 1478ms\nProduction Profiling: 2179ms\nSo it looks like performance hit is not that bad, but it’s still there. We wouldn’t recommend to just push profiling bundles to production. Just build one when needed and profile on your development machine or build it each time and deploy alongside your production build on separate url. This way you can always switch to profiling build and do your analysis while not sacrificing your users performance.\nInteractions —\n🧨 Watch out, this is an experimental API and might change in future versions of React\n—\nAlong with the profiler API React team has introduced an interaction tracking that can be attached to profiling data. Sometimes it’s just hard to find out which exact user action or backend call ended up with very slow render commit. What this API allows, is to attach a bit of semantic context to recorded performance traces.\nSometimes we can track the component that is slow, and tack slow sessions, but it’s not always easy to find out which exact user interaction is causing this. Especially when we are trying to gather performance data remotely, from user machine, as it’s not showing up on our environment. Thanks to the interactions API we’re able to see exactly which user actions are slow and which are fast, even if they are triggering the same component or we don’t exactly know where to look for the problem.\nWhat we can see on the screen above, is a trace of user interactions on the same component. Based on grid color we can see, that “Enter user name” action is pretty fast. What we should be looking at is the “Randomize button” action. Its marker color is yellow and render duration is much bigger. Also when looking from the commit perspective it can be found, that this action is problematic:\nAnd here’s how we track interaction in this example:\nimport { unstable_trace as trace, } from \"scheduler/tracing\"``\u003cinput type=\"text\" value={name} onChange={e =\u003e { trace(\"Enter user name\", performance.now(), () =\u003e onChange(e.target.value) ) }} /\u003e What we do here, is on each character entered in the input we call trace first, passing in high resolution timestamp and a callback to handle actual logic after interaction is recorded. Don\"t worry about the performance object. It\"s a global available in every major browser now. We use it here, because Date.now() is not good enough to measure code performance. You can read more about it in your browser documentation, ex: performance-mdn.\nThere’s one more thing we’re missing here. It’s how to add interactions to asynchronous code. A lot of performance issues are related to data we’re fetching from backend. If we use this simple trace API, our async code calls will not be counted as part of the interaction. That\"s simply because of the way async is handled in JS. What we need to do then is to wrap callbacks of async code with container that will bind it to current interaction. Thankfully React already has tools to support it:\nimport { unstable_trace as trace, unstable_wrap as wrap, } from \"scheduler/tracing\"``\u003cbutton onClick={() =\u003e trace(\"Fetch data\", performance.now(), () =\u003e { setLoading(true) fetchData() .then( wrap(data =\u003e { setData(data) }) ) .finally(wrap(() =\u003e setLoading(false))) }) } \u003e Fetch data \u003c/button\u003e What’s most important here, is the wrap call that is surrounding then and finally handlers in our async call. After that we should see, that all renders related to this call are assigned to the same interaction:\nWe can see here, that “Fetch data” has exactly 3 renders associated. This totally makes sense. First one is sue to loading being set to true, second when we finish fetching the data and third when loading is set back to false. Of course all this code does not need to be inlined in the component. Interaction tracing API can as well be used inside custom hooks:\nimport { unstable_trace as trace, unstable_wrap as wrap, } from \"scheduler/tracing\"``const useData = () =\u003e { const [loading, setLoading] = useState(false) const [data, setData] = useState(null)``const fetch = () =\u003e { setLoading(true) fetchData() .then( wrap(data =\u003e { setData(data) }) ) .finally(wrap(() =\u003e setLoading(false))) } return { fetch, loading, data } }``const Component = () =\u003e { const { fetch, loading, data } = useData()``return \u003cbutton onClick={() =\u003e trace(\"Fetch data\", performance.now(), fetch)} \u003e Fetch data \u003c/button\u003e } Details and Techniques In this chapter we take a look at other cases (except our “Quick Win”) that make React Profiler worth while. We also talk about cases where it’s not very useful and what to do if we cannot get any meaningful input from it.\nUsing profiler in other browsers While Chrome is the leading browser (at least as of 2021) we sometimes also need to support clients using other agents — noticeable ones being Safari and mobile safari. For this we’ll be using standalone version of React Dev Tools and connect it remotely:\nTo get standalone tools fetch it with yarn or npm and simply start: npm install -g react-devtools react-devtool\nWhat you should get is a welcome screen with information about how to connect. For browsers it should be as easy as adding a script to your page section: and reloading the page. This will open a web-socket connection from your browser to the app used for all communication between debugger/profiler and dev-tools.\nUnfortunately it has to run before ReactDOM is loaded, so it cannot be added in dev-tools when page is already shown in your browser. Just make sure you remove it from the code before committing or maybe you already have a separate html template for development and production. Then just put it only in dev one.\nAfter a few seconds your app should connect and you should be able to use the same tools as in Chrome extension, but within unsupported browsers.\nThis solution will also work just fine for iOS Simulator. For Android emulator/device you’ll need another step — connect phone using cable and proxy all requests to localhost from your device to host: adb reverse tcp:8097 tcp:8097\nUnfortunately there’s no easy way to use it with real iOS device. Due to security considerations React Dev Tools listen only on localhost and there’s no equivalent for adb reverse for iOS.\nUnexpected renders of memoized components React.memo is usually treated as a holy grail and universal tool to fix all your performance problems. But sometimes it simply doesn\"t seem to work. Usually it\"s due to misunderstanding of how it works or what is really passed into component props. Let\"s try to investigate such case using React Profiler and what to look for when we suspect memoization is not working. Here\"s our suspected component:\nconst SlowComponent = React.memo(({ text, onClick }) =\u003e { const arr = [] for (var i = 1000000 - 1; i \u003e= 0; i--) { arr.push(i) } return ( \u003cdiv\u003e \u003cdiv\u003eI\"m slow {text}\u003c/div\u003e \u003cbutton onClick={onClick}/\u003e \u003c/div\u003e ) }) It looks like it’s being correctly optimized. But let’s use it in a way that simply passes an inline function as a onChange parameter. This will basically make out React.memo useless, but what we want to do is to check how will this error manifest itself in React Profiler.\nconst App = () =\u003e { const loadData = id =\u003e ({ id, value: \"some\" }) const [_, setDummy] = useState()``return ( \u003cdiv className=\"App\"\u003e \u003cbutton onClick={() =\u003e setDummy(Date.now())}\u003eRender\u003c/button\u003e \u003cSlowComponent onClick={() =\u003e loadData(\"dummy\")} /\u003e \u003c/div\u003e ) } To investigate problem like this, we need to have at least 2 renders of parent component without any changes in data passed to SlowComponent. In this example it\"s actually easy. We\"ll just press a button few times and it should re-render the App component. The only prop we pass in is this problematic inline function. Thanks to React.memo it should never re-render. The only moment this component should show up colored in the profiler is its initial mount. Let\"s see how it actually behaves in the profiler:\nWe can see here, that it has been rendered on each button press, and it has taken quite a lot of time. Thanks to the popup you also see, that it’s due to onClick property changing. This is not what we wanted here, let\"s fix this inline function and check how will profiler output look like afterwards. Wrapping it in a simple useCallback should be enough here:\nconst App = () =\u003e { const loadData = id =\u003e ({ id, value: \"some\" }) const [_, setDummy] = useState()``return ( \u003cdiv className=\"App\"\u003e \u003cbutton onClick={() =\u003e setDummy(Date.now())} /\u003e \u003cSlowComponent onClick={React.useCallback(() =\u003e loadData(\"dummy\"), [])} /\u003e \u003c/div\u003e ) } And here’s how profiling results look like:\nSlowComponent did not render anywhere except of initial mount. That\"s the result we have expected and it is clearly shown in the profiler data. This example might be trivial, but when investigating performance of theoretically optimized components you\"ll be able to easily see them re-rendering in the profiler. Hovering on the component will also show why it has rendered. With this information it should be fairly easy to fix.\nUsing update highlights to find unneeded renders There’s one more quick way to pinpoint components like that. It’s not really a profiler feature, but React Developer Tools have also an option to mark all rendered components with color borders. It’s especially useful to track forms re-renders. Often we’ll see some undesired renders when we were hoping that only single input was updated. Let’s enable the option now and check how it looks like.\nIn the screen below we can see a 3 input form. We’re editing first text input with “Highlight updates when components render” option enabled:\nAs you can see, on each character we put into the “What’s your name?” box, we have a render on all inputs and parent component. Parent re-rendering is probably fine, as it’s the place where we keep the state for the form. But all other inputs are not really related to the change, so we can optimize it.\nIn this particular case it might be an overkill to do it just for 2 inputs. But, especially when working with redux you might see some updates that are totally unexpected. Enabling “Highlight updates when components render” can be the only thing that you need to find performance issues then. It might be worth to enable it from time to time and play around with your app. You might be surprised how many unneeded renders are there.\n","wordCount":"4805","inLanguage":"en","image":"https://marekpiechut.github.io/images/1.jpeg","datePublished":"2021-06-30T06:32:56.234Z","dateModified":"2024-06-30T12:44:09Z","author":{"@type":"Person","name":"Marek Piechut"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/"},"publisher":{"@type":"Organization","name":"rand(4) Thoughts","logo":{"@type":"ImageObject","url":"https://marekpiechut.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://marekpiechut.github.io/ accesskey=h title="rand(4) Thoughts (Alt + H)">rand(4) Thoughts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://marekpiechut.github.io/ title=Home><span>Home</span></a></li><li><a href=https://marekpiechut.github.io/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://marekpiechut.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://marekpiechut.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Investigate poor performance React components with “React Profiler”</h1><div class=post-meta><span title='2021-06-30 06:32:56.234 +0000 UTC'>June 30, 2021</span>&nbsp;·&nbsp;Marek Piechut</div></header><figure class=entry-cover><img loading=eager srcset="https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/images/1_hu8ad64f1424960d9be5e28e2bedcef51e_42498_360x0_resize_q75_box.jpeg 360w ,https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/images/1_hu8ad64f1424960d9be5e28e2bedcef51e_42498_480x0_resize_q75_box.jpeg 480w ,https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/images/1_hu8ad64f1424960d9be5e28e2bedcef51e_42498_720x0_resize_q75_box.jpeg 720w ,https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/images/1.jpeg 800w" sizes="(min-width: 768px) 720px, 100vw" src=https://marekpiechut.github.io/post/2021-06-30_investigate-poor-performance-react-components-with-react-profiler/images/1.jpeg alt width=800 height=533></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#quick-win aria-label="Quick Win">Quick Win</a></li><li><a href=#install-react-profiler aria-label="Install React Profiler">Install React Profiler</a></li><li><a href=#investigate-slow-page aria-label="Investigate slow page">Investigate slow page</a></li><li><a href=#memoize-component aria-label="Memoize Component">Memoize Component</a></li><li><a href=#wrap-up aria-label="Wrap Up">Wrap Up</a></li><li><a href=#deep-dive aria-label="Deep dive">Deep dive</a></li><li><a href=#profiler-ui aria-label="Profiler UI">Profiler UI</a></li><li><a href=#react-profiler-api aria-label="React Profiler API">React Profiler API</a></li><li><a href=#profiling-in-production-builds aria-label="Profiling in production builds">Profiling in production builds</a></li><li><a href=#performance-impact aria-label="Performance impact">Performance impact</a></li><li><a href=#interactions aria-label=Interactions>Interactions</a></li><li><a href=#details-and-techniques aria-label="Details and Techniques">Details and Techniques</a></li><li><a href=#using-profiler-in-other-browsers aria-label="Using profiler in other browsers">Using profiler in other browsers</a></li><li><a href=#unexpected-renders-of-memoized-components aria-label="Unexpected renders of memoized components">Unexpected renders of memoized components</a><ul><li><a href=#using-update-highlights-to-find-unneeded-renders aria-label="Using update highlights to find unneeded renders">Using update highlights to find unneeded renders</a></li></ul></li></ul></div></details></div><div class=post-content><p>This post is a work in progress chapter from “React Performance” book i’ve started working on and haven’t touched for few months. Looks like it will never be released, so I’ll just post parts that I think might be useful as blog posts._You’re probably here, because you already know that something is wrong with a part of your application. Maybe after some change, maybe when hit with a big dataset, your component/screen started to get slow. You probably can see it when you invoke some action, that UI is no longer responsive and you’re pretty sure it’s React rendering that takes too long.</p><p>You’re already thinking about adding some <code>useCallback</code>, <code>useMemo</code>, and <code>React.memo</code> calls, but where? Sometimes it"s obvious. Component structure is simple and you have the gut feeling what might be causing the problem. But sometimes you just stare at the code and have no idea where, in this huge component tree, we"re dropping these frames. Which component to wrap with memo or which callback is responsible for component re-rendering regardless of nothing changing in it"s data.</p><h3 id=quick-win>Quick Win<a hidden class=anchor aria-hidden=true href=#quick-win>#</a></h3><p>In this section we’ll try to answer exactly that — <strong>how to find that one component (or group of components) that is causing the slowdown</strong>.</p><p>Let’s start with quickest way we can get to the answer. React already has some nice tools that will help us out. We’ll dive into React Profiler and without much introduction just try to hunt the performance hog.</p><h3 id=install-react-profiler>Install React Profiler<a hidden class=anchor aria-hidden=true href=#install-react-profiler>#</a></h3><p>—</p><p>🤔 Feel free to skip this section if you already have it installed.</p><p>—</p><p>React profiler is a part of totally awesome React Developer Tools package available for Chrome/Chromium and Firefox. You can download it here:</p><ul><li><strong>Chrome:</strong> <a href=https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi><strong>https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</strong></a></li><li><strong>Firefox:</strong> <a href=https://addons.mozilla.org/en-US/firefox/addon/react-devtools/><strong>https://addons.mozilla.org/en-US/firefox/addon/react-devtools/</strong></a></li></ul><p>Both are being developed by core React team and built from the same codebase, so they should provide the same functionality. So it shouldn’t matter which one you use. Just select browser you’re most comfortable to work with. Unfortunately there’s no support for other tools as of now. You’ll have to use standalone edition if you need to debug/profile these (we’ll dive into that later on).</p><p>After installation you should be able to access React profiler inside your browser developer tools (we’re looking for the <code>Components</code> and <code>Profiler</code> tabs):</p><p><img loading=lazy src=images/2.png#layoutTextWidth alt=image></p><p>When you have it all and running open your application in the browser, navigate to <code>Profiler</code> tab and start profiling (Press blue circle button in the top left corner). Click around your app for few seconds and stop it by pressing red circle button . If you didn"t get any errors we should be all set and ready to dive into it.</p><p>—</p><p>⚠️ <em>I’m getting</em> <strong><em>“Profiling not supported.”</em></strong> <em>message, what next?</em> — make sure you’re running your React app in development mode. Profiling is disabled by default on production builds. Don’t worry for now. Will handle it later. Just switch to development mode. Most of the performance issues will be visible in both — production and development builds anyways.</p><p>—</p><h3 id=investigate-slow-page>Investigate slow page<a hidden class=anchor aria-hidden=true href=#investigate-slow-page>#</a></h3><p>Now that we have our profiler running we can go on and try to investigate some slowly loading page in your app. We’ll be investigating a lazy loaded list of old notifications. We expect it to be doing more work than required when each load is finished, but we encourage you to open up application you’re currently developing and check a page that you think might need some performance improvements and it’s not related to network time.</p><p>So let’s dit into it. As always we start with a clean state to make sure we’re touching only code we think we do and that nothing is going to skew our measurements, so:</p><p>✔️ Checkout to a commit you want to profile or stage your current changes</p><p>✔️ Make sure theres not much going on on your machine. CPU or memory hungry applications might skew our results.</p><p>And here’s the screen we’ll be working on:</p><p><img loading=lazy src=images/3.png#layoutTextWidth alt=image></p><p>It’s currently showing the last 20 notifications, but we have many more on the backend and whenever you’re near the bottom we’ll be fetching new ones and appending to the list. Just classic lazy loading infinite (Of course it’s not infinite, we’ll run out of notifications in few screens, but it has enough to make it interesting) scroll.</p><p>What we need to do now, after initial rendering of the page is done, is to gather a profiler baseline, so we know if we’re fixing performance or making it worse. Let’s open React Profiler, start recording and scroll down until we hit the lazy load boundary few times, at least twice. Then immediately stop the profiling session. Output should be similar to what you see on the screenshot below.</p><p><img loading=lazy src=images/4.png#layoutTextWidth alt=image></p><p>That’s a lot of output, but we’re not really interested in all of that. We start by investigating the commits chart at the top:</p><p><img loading=lazy src=images/5.png#layoutTextWidth alt=image></p><p>What we can see here, is that we had 20 <em>“commits”</em> — 20 times React has applied changes to the browser DOM. That’s not bad actually when we think about all the loading state changes and that we’ve executed lazy loads few times. What is more interesting though, is that this chart is constantly moving up, so it looks like we’re doing more and more work on each commit. When you hover over the bars, you’ll also see, that we get from around 90ms to almost 200ms time for single render. This is probably now what we were expecting. We are fetching 20 items in each batch and appending them to the list. Of course we’re doing some more work when going through ever-growing list of items, but we should only append new 20 nodes to the DOM tree. It looks suspicious, let’s dig into it a little bit more.</p><p>To do that, we start at the last commit and check what was rendered there.</p><p><img loading=lazy src=images/6.png#layoutTextWidth alt=image></p><p>We can ignore all the grey bars — these components did not change during this render. First interesting one is the <code>Notifications</code> component. It did render, and that"s expected. We have changed its state, so this looks fine. We also see, that commit of <code>Notifications</code> component itself did not take a lot of time. It"s only 3.5ms. But take a look on all these small components at the bottom. All of them are colored, so they all have changed and their DOM changes were applied. Compare them to the previous screen. We see that in each commit there"s more and more of these, and all of them are always rendered. If you hover over them, you"ll see, that they are the individual notifications.</p><p><img loading=lazy src=images/7.png#layoutTextWidth alt=image></p><p>Also, if you did not refresh the page or change page structure, React Profiler will highlight actual nodes that were rendered during the commit. Scrolling to the top of the page and hovering over one of the first nodes in the flame chart will reveal the truth. We’re re-rendering every notification on each update.</p><p><img loading=lazy src=images/8.png#layoutTextWidth alt=image></p><p>This makes no sense. These components will never change. We only append new notifications at the end. There’s no way data can change and they should not trigger any DOM updates. It looks like we’ve found good place to try out <code>React.memo</code>. Let"s wrap our <code>NotificationItem</code> into it and see if it helps.</p><h3 id=memoize-component>Memoize Component<a hidden class=anchor aria-hidden=true href=#memoize-component>#</a></h3><p>Digging into the source code it looks like we’re using just a regular functional component for a single notification item. Usually that’s totally fine and in most cases should not matter. But here we’re rendering quite a lot of them and it makes sense to give it few minutes of thought and try to memoize rendered component. Here’s how it look like right now. Actual body of the component does not matter, it’s only important that it is a functional component and that it’s not memoized yet.
<code>const NotificationItem = ({ notification, onMarkAsRead, session }: Props) => &lt;div>...&lt;/div></code></p><p>Ok, let’s wrap it up with <code>React.memo</code> and see if it helps:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>NotificationItem</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>&lt;</span><span class=nt>Props</span><span class=p>&gt;(</span>  
</span></span><span class=line><span class=cl>  <span class=p>({</span> <span class=nx>notification</span><span class=p>,</span> <span class=nx>onMmarkAsRead</span><span class=p>,</span> <span class=nx>session</span> <span class=p>})</span> <span class=o>=&gt;</span> <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;...&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Now rebuild project, and start a new profiling session. Make sure that you have similar environment (nothing heavy is running on your computer and you gave few seconds for VM to warm up). And check if our fix has helped to mitigate the problem:</p><p><img loading=lazy src=images/9.png#layoutTextWidth alt=image></p><p>Yup, looks like the problem is fixed. In the commits bar we can see a <em>“rake”</em> pattern. Lower bar being a render of loading indicator, when no notification change, and higher bar being actual rendering of newly fetched data. Also each render takes similar time now — around 60–70ms and looking at the flame chart at the bottom we see, that previously fetched notifications are not re-rendered (they are greyed out).</p><h3 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h3><p>Looks like we have fixed our problem and here we have our quick win. It was enough to simply wrap a component with <code>React.memo</code>. But what"s more important here is that we"ve made an informed change. There was no guesswork about where the problem is. We had hard evidence, that there was unnecessary work being done and then we have fixed it.</p><p>—</p><p>⚠️ There’s some more consideration needed when using <code>React.memo</code>. Sometimes adding it adds more overhead instead of fixing the problem. It might be the case, that it won’t help in your project.</p><p>—</p><h3 id=deep-dive>Deep dive<a hidden class=anchor aria-hidden=true href=#deep-dive>#</a></h3><p>React Profiler is a nice tool to quickly investigate possible performance issues in rendering process. In this chapter we’ll be doing a deep dive into how it works and what actually it measures. We’ll also take a look at React APIs that are used internally by the profiler and investigate how we might use it ourselves to get more answers than React Profiler provides.</p><h3 id=profiler-ui>Profiler UI<a hidden class=anchor aria-hidden=true href=#profiler-ui>#</a></h3><p>Let’s take a detailed look into information available in React Profiler and how it’s presented. To have a better image of what is going on here, we need to remember about 2 stages of React rendering process:</p><ul><li>First stage called <strong>Render</strong> or <strong>Reconciliation</strong> is one that calls all render functions on components, generates a Virtual DOM and compares it to the previous vDOM. This way it knows which nodes have changed and need to be applied to the browser DOM.</li><li>Second stage — <strong>Commit</strong> — responsible for doing actual changes on browser DOM. This has to be done in single call to the browser APIs and will be done in <em>“stop the world”</em> manner. If we would allow it to be done in stages or in background, user would see intermediate stages while we are updating the UI.</li></ul><p>With that in mind we can now take a look at the commits view in the profiler. It’s this small bar chart at the top:</p><p><img loading=lazy src=images/10.png#layoutTextWidth alt=image></p><p>What we see here is a list of all commits that React has flushed to DOM during our profiling session. Each bar is showing a separate commit in sequence of execution. Although it shows commits, it does count the render phase. You can test it out using this simple code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>useState</span> <span class=p>}</span> <span class=kr>from</span> <span class=s2>&#34;react&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>SlowComponent</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>noSlowdown</span> <span class=p>})</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=p>[]</span>  
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>noSlowdown</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>1000000</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>      <span class=nx>arr</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span><span class=nx>I</span><span class=s2>&#34;m slooooooow&lt;/div&gt;  
</span></span></span><span class=line><span class=cl><span class=s2>}
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>const FastComponent = () =&gt; {  
</span></span></span><span class=line><span class=cl><span class=s2>  return &lt;div&gt;I&#34;</span><span class=nx>m</span> <span class=nx>fassssst</span><span class=p>....&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>App</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>dummy</span><span class=p>,</span> <span class=nx>setDummy</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>className</span><span class=o>=</span><span class=s>&#34;App&#34;</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>SlowComponent</span> <span class=na>noSlowdown</span><span class=o>=</span><span class=p>{</span><span class=nx>dummy</span> <span class=o>%</span> <span class=mi>2</span><span class=p>}</span> <span class=p>/&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>FastComponent</span> <span class=p>/&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=nx>setDummy</span><span class=p>(</span><span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>())}&gt;</span><span class=nx>Render</span><span class=o>!</span><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=nx>App</span>
</span></span></code></pre></div><p>Loading it and pressing <code>Render!</code> button few times shows that slow component is impacting profiling results regardless of it returning the same trivial single <code>div</code>. Commit cost of both components is exactly the same, yet profiling results are completely different: fast component renders nearly instantly while slow component takes 32ms out of 33ms total rendering time.</p><p><img loading=lazy src=images/11.png#layoutTextWidth alt=image></p><p>Traveling back and fourth through the commits you can find some interesting patterns in render times that you didn’t expect. Selecting one of them will show you exact render duration and few more details about it.</p><p>As you have probably already noticed React Profiler marks commits and components with different colors and bar length. Generally the longer the bar and warmer the color (more yellow), the more time it took to render compared to other commits and components. Grey lines did not render at all during given run.</p><p>—</p><p>🤔 <strong>Note:</strong></p><ul><li>Line length shows how long did it take for component to render with all it’s children</li><li>Line color shows how long did component itself render compared to other components (how slow/fast it is)</li></ul><p>—</p><p>There are two more interesting views here: <strong>Flamegraph</strong> and <strong>Ranked</strong> tab. First shows all components in your view in a tree according to your components structure. Second orders components by their rendering time ( <strong>self render time</strong> — how long it took to render component excluding its children time). It’s very useful to catch slowest components — a good place to start searching for problems. Hovering on the bars will highlight it on the page and selecting one of them will show you history of commits of given components and <strong>reason why render was triggered</strong> (ex: state change, parent render, props change, etc.). This information is sometimes enough to get you on track with figuring out what’s wrong. Very often some props change, that we didn’t expect to be any different.</p><p>—</p><p>⚠️ It’s usually good idea to have <em>“Record why each component rendered while profiling.”</em> option enabled. It might add some overhead to profiling process, but it’s usually not a problem if your app is not super-huge. Just press the options cog ⚙️ and enable it now.</p><p>—</p><p>There’s also an option to hide commits that took below given time. It’s not super useful, as we usually are looking for anomalies, and want to see whole picture. It’s better idea to narrow use case to short problematic interaction, but you might also start with longer recording sessions and try to find issues using this filter.</p><h3 id=react-profiler-api>React Profiler API<a hidden class=anchor aria-hidden=true href=#react-profiler-api>#</a></h3><p>DevTools profiler allows to gain a lot of knowledge about performance issues in your app. But if what you need is to profile only selected component and do it in production, there’s also a React Profiler API (<a href=https://reactjs.org/docs/profiler.html>https://reactjs.org/docs/profiler.html</a>). It’s a lightweight component to gather data about it render times, thus giving an insight of performance of its children.</p><p>It will not allow us to get a deep tree of render stats like we have in Profiler view in DevTools, but allows to programmatically get timings for selected components in the app. Usage is simple, just wrap your component and provide <code>onRender</code> callback:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>Profiler</span>  
</span></span><span class=line><span class=cl> <span class=na>id</span><span class=o>=</span><span class=s>&#34;user-profile&#34;</span>  
</span></span><span class=line><span class=cl> <span class=na>onRender</span><span class=o>=</span><span class=p>{(</span>  
</span></span><span class=line><span class=cl>  <span class=nx>id</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>phase</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>actualTime</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>baseTime</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>startTime</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>commitTime</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>interactions</span>  
</span></span><span class=line><span class=cl> <span class=p>)</span> <span class=o>=&gt;</span> <span class=nx>aggregatePerformance</span><span class=p>(</span><span class=nx>id</span><span class=p>,</span> <span class=nx>phase</span><span class=p>,</span> <span class=nx>actualDuration</span><span class=p>,</span> <span class=nx>interactions</span><span class=p>)}</span>  
</span></span><span class=line><span class=cl><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl> <span class=p>&lt;</span><span class=nt>UserProfile</span> <span class=na>user</span><span class=o>=</span><span class=p>{</span><span class=nx>user</span><span class=p>}</span> <span class=p>/&gt;</span>  
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>Profiler</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>We’ve got quite a few parameters to the callback, but except of that it looks pretty straightforward. Let’s go through all the data we have in the callback:</p><ul><li><strong>id</strong> — this is exactly the same as what we have passed into the <code>Profiler</code> tag. React does nothing interesting with this parameter. It"s not grouping or overriding profiler tags with same Id. You can have as many as you want with exactly same value. Its role is purely informational, so you can have single callback, reuse it between profilers and still know which measures you have received.</li><li><strong>phase</strong> — component lifecycle phase. This can only be: <code>mount</code> or <code>update</code> and means exactly what you expect. Can be used find out if problem is only appearing during mount - maybe some slow <code>useEffect</code> that is firing only on mount.</li><li><strong>actualTime</strong> — measured duration of rendering. This is a real time of render during given commit. If you’re using memoization this time should go down significantly. If it does not, then you might found the problem.</li><li><strong>baseTime</strong> — estimated time of full render of component subtree. This should roughly be the same time as the <em>actualTime</em> when component did mount if it did not do any heavy initialization. If you’re using memoization correctly, this time should be usually larger.</li><li><strong>startTime</strong> — simply a timestamp when rendering started</li><li><strong>commitTime</strong> — timestamp when rendering was finished. This time is shared between all profilers that took part in the commit. Thanks to that you can group data from separate sub-trees that were rendered due to same change in state.</li><li><strong>interactions</strong> — list of all interactions associated with this render.</li></ul><p>Profiler API is very simple and allows to track performance of our components even on production. Just keep in mind, that it has a cost associated. There’s a small performance penalty for each <code>Profiler</code> instance in your components tree. Also make sure you"re not doing a lot of processing in your callback. It"s best to do any calculations asynchronously, or just dump your data to server and do all heavy-lifting there.</p><h3 id=profiling-in-production-builds>Profiling in production builds<a hidden class=anchor aria-hidden=true href=#profiling-in-production-builds>#</a></h3><p>Due to small performance impact profiler API is disabled in production builds of React (as of May 2021). While it’s usually not a problem, as most of real performance issues will be visible in both production and development builds. Sometimes you want to dig into production bundle and gain some insights on rendering time.</p><p>The way it’s currently being disabled is through build time configuration. So if you have built your app with regular ReactDOM, you’ll have to re-build it. Here’s what to put in Webpack config to switch to profiling versions of libraries:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=c1>//...  
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>resolve</span><span class=o>:</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nx>alias</span><span class=o>:</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>      <span class=s2>&#34;react-dom$&#34;</span><span class=o>:</span> <span class=s2>&#34;react-dom/profiling&#34;</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>      <span class=s2>&#34;scheduler/tracing&#34;</span><span class=o>:</span> <span class=s2>&#34;scheduler/tracing-profiling&#34;</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>  <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>In case you’re using <code>create-react-app</code> script, just add <code>--profile</code> flag during build process:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Using Yarn  </span>
</span></span><span class=line><span class=cl>yarn build --profile  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Using NPM </span>
</span></span><span class=line><span class=cl>npm run build -- --profile
</span></span></code></pre></div><p>With all this in place profiling should work just fine in production build. Regardless of that we’re not really advising to add it to your build process. It should be enough to run this build locally and connecting it to production backend. It should be trivial if you’re already serving your app from CDN or static folder using your Web server.</p><h3 id=performance-impact>Performance impact<a hidden class=anchor aria-hidden=true href=#performance-impact>#</a></h3><p>As we have already noticed, profiler builds tend to run slower. Even if you’re not actively profiling. We’ve done a quick benchmark to actually measure it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ROUNDS</span> <span class=o>=</span> <span class=mi>100</span><span class=nx>_000</span>  
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Benchmark</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>took</span><span class=p>,</span> <span class=nx>setTook</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>round</span><span class=p>,</span> <span class=nx>setRound</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>start</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=nx>performance</span><span class=p>.</span><span class=nx>now</span><span class=p>())</span><span class=sb>``</span><span class=nx>useEffect</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>round</span> <span class=o>&lt;</span> <span class=nx>ROUNDS</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>      <span class=nx>setRound</span><span class=p>(</span><span class=nx>round</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>      <span class=nx>setTook</span><span class=p>(</span><span class=nx>performance</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span> <span class=o>-</span> <span class=nx>start</span><span class=p>.</span><span class=nx>current</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=nx>round</span><span class=p>])</span><span class=sb>``</span><span class=k>return</span> <span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>className</span><span class=o>=</span><span class=s>&#34;App&#34;</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;{</span><span class=nx>round</span><span class=p>}&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span><span class=nx>Took</span><span class=o>:</span> <span class=p>{</span><span class=nx>took</span><span class=p>}</span><span class=nx>ms</span><span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And results are:</p><p>Development: <strong>13575ms</strong><br>Production: <strong>1478ms</strong><br>Production Profiling: <strong>2179ms</strong></p><p>So it looks like performance hit is not that bad, but it’s still there. We wouldn’t recommend to just push profiling bundles to production. Just build one when needed and profile on your development machine or build it each time and deploy alongside your production build on separate url. This way you can always switch to profiling build and do your analysis while not sacrificing your users performance.</p><h3 id=interactions>Interactions<a hidden class=anchor aria-hidden=true href=#interactions>#</a></h3><p>—</p><p>🧨 Watch out, this is an experimental API and might change in future versions of React</p><p>—</p><p>Along with the profiler API React team has introduced an interaction tracking that can be attached to profiling data. Sometimes it’s just hard to find out which exact user action or backend call ended up with very slow render commit. What this API allows, is to attach a bit of semantic context to recorded performance traces.</p><p>Sometimes we can track the component that is slow, and tack slow sessions, but it’s not always easy to find out which exact user interaction is causing this. Especially when we are trying to gather performance data remotely, from user machine, as it’s not showing up on our environment. Thanks to the interactions API we’re able to see exactly which user actions are slow and which are fast, even if they are triggering the same component or we don’t exactly know where to look for the problem.</p><p><img loading=lazy src=images/12.png#layoutTextWidth alt=image></p><p>What we can see on the screen above, is a trace of user interactions on the same component. Based on grid color we can see, that <em>“Enter user name”</em> action is pretty fast. What we should be looking at is the <em>“Randomize button”</em> action. Its marker color is yellow and render duration is much bigger. Also when looking from the commit perspective it can be found, that this action is problematic:</p><p><img loading=lazy src=images/13.png#layoutTextWidth alt=image></p><p>And here’s how we track interaction in this example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=nx>unstable_trace</span> <span class=kr>as</span> <span class=nx>trace</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kr>from</span> <span class=s2>&#34;scheduler/tracing&#34;</span><span class=sb>``</span><span class=p>&lt;</span><span class=nt>input</span>  
</span></span><span class=line><span class=cl>  <span class=na>type</span><span class=o>=</span><span class=s>&#34;text&#34;</span>  
</span></span><span class=line><span class=cl>  <span class=na>value</span><span class=o>=</span><span class=p>{</span><span class=nx>name</span><span class=p>}</span>  
</span></span><span class=line><span class=cl>  <span class=na>onChange</span><span class=o>=</span><span class=p>{</span><span class=nx>e</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nx>trace</span><span class=p>(</span><span class=s2>&#34;Enter user name&#34;</span><span class=p>,</span> <span class=nx>performance</span><span class=p>.</span><span class=nx>now</span><span class=p>(),</span> <span class=p>()</span> <span class=o>=&gt;</span>  
</span></span><span class=line><span class=cl>       <span class=nx>onChange</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>)</span>  
</span></span><span class=line><span class=cl>  <span class=p>}}</span>  
</span></span><span class=line><span class=cl><span class=p>/&gt;</span>
</span></span></code></pre></div><p>What we do here, is on each character entered in the input we call <code>trace</code> first, passing in high resolution timestamp and a callback to handle actual logic after interaction is recorded. Don"t worry about the <code>performance</code> object. It"s a global available in every major browser now. We use it here, because <code>Date.now()</code> is not good enough to measure code performance. You can read more about it in your browser documentation, ex: <a href=https://developer.mozilla.org/en-US/docs/Web/API/Performance_API>performance-mdn</a>.</p><p>There’s one more thing we’re missing here. It’s how to add interactions to <strong>asynchronous code</strong>. A lot of performance issues are related to data we’re fetching from backend. If we use this simple <code>trace</code> API, our async code calls will not be counted as part of the interaction. That"s simply because of the way async is handled in JS. What we need to do then is to wrap callbacks of async code with container that will bind it to current interaction. Thankfully React already has tools to support it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=nx>unstable_trace</span> <span class=kr>as</span> <span class=nx>trace</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>unstable_wrap</span> <span class=kr>as</span> <span class=nx>wrap</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kr>from</span> <span class=s2>&#34;scheduler/tracing&#34;</span><span class=sb>``</span><span class=p>&lt;</span><span class=nt>button</span>  
</span></span><span class=line><span class=cl>  <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=nx>trace</span><span class=p>(</span><span class=s2>&#34;Fetch data&#34;</span><span class=p>,</span> <span class=nx>performance</span><span class=p>.</span><span class=nx>now</span><span class=p>(),</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>      <span class=nx>setLoading</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>      <span class=nx>fetchData</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=nx>then</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>          <span class=nx>wrap</span><span class=p>(</span><span class=nx>data</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=nx>setData</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>          <span class=p>})</span>  
</span></span><span class=line><span class=cl>        <span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=k>finally</span><span class=p>(</span><span class=nx>wrap</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=nx>setLoading</span><span class=p>(</span><span class=kc>false</span><span class=p>)))</span>  
</span></span><span class=line><span class=cl>    <span class=p>})</span>  
</span></span><span class=line><span class=cl>  <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=nx>Fetch</span> <span class=nx>data</span>  
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>What’s most important here, is the <code>wrap</code> call that is surrounding <code>then</code> and <code>finally</code> handlers in our async call. After that we should see, that all renders related to this call are assigned to the same interaction:</p><p><img loading=lazy src=images/14.png#layoutTextWidth alt=image></p><p>We can see here, that <em>“Fetch data”</em> has exactly 3 renders associated. This totally makes sense. First one is sue to <code>loading</code> being set to <code>true</code>, second when we finish fetching the data and third when <code>loading</code> is set back to <code>false</code>. Of course all this code does not need to be inlined in the component. Interaction tracing API can as well be used inside custom hooks:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=nx>unstable_trace</span> <span class=kr>as</span> <span class=nx>trace</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>  <span class=nx>unstable_wrap</span> <span class=kr>as</span> <span class=nx>wrap</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kr>from</span> <span class=s2>&#34;scheduler/tracing&#34;</span><span class=sb>``</span><span class=kr>const</span> <span class=nx>useData</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>loading</span><span class=p>,</span> <span class=nx>setLoading</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>data</span><span class=p>,</span> <span class=nx>setData</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=kc>null</span><span class=p>)</span><span class=sb>``</span><span class=kr>const</span> <span class=nx>fetch</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nx>setLoading</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=nx>fetchData</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=nx>then</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>        <span class=nx>wrap</span><span class=p>(</span><span class=nx>data</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>          <span class=nx>setData</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>})</span>  
</span></span><span class=line><span class=cl>      <span class=p>)</span>  
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=k>finally</span><span class=p>(</span><span class=nx>wrap</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=nx>setLoading</span><span class=p>(</span><span class=kc>false</span><span class=p>)))</span>  
</span></span><span class=line><span class=cl>  <span class=p>}</span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span> <span class=nx>fetch</span><span class=p>,</span> <span class=nx>loading</span><span class=p>,</span> <span class=nx>data</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span><span class=sb>``</span><span class=kr>const</span> <span class=nx>Component</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>fetch</span><span class=p>,</span> <span class=nx>loading</span><span class=p>,</span> <span class=nx>data</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>useData</span><span class=p>()</span><span class=sb>``</span><span class=k>return</span> <span class=p>&lt;</span><span class=nt>button</span>  
</span></span><span class=line><span class=cl>  <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=nx>trace</span><span class=p>(</span><span class=s2>&#34;Fetch data&#34;</span><span class=p>,</span> <span class=nx>performance</span><span class=p>.</span><span class=nx>now</span><span class=p>(),</span> <span class=nx>fetch</span><span class=p>)}</span>  
</span></span><span class=line><span class=cl><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=nx>Fetch</span> <span class=nx>data</span>  
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=details-and-techniques>Details and Techniques<a hidden class=anchor aria-hidden=true href=#details-and-techniques>#</a></h3><p>In this chapter we take a look at other cases (except our <em>“Quick Win”</em>) that make React Profiler worth while. We also talk about cases where it’s not very useful and what to do if we cannot get any meaningful input from it.</p><h3 id=using-profiler-in-other-browsers>Using profiler in other browsers<a hidden class=anchor aria-hidden=true href=#using-profiler-in-other-browsers>#</a></h3><p>While Chrome is the leading browser (at least as of 2021) we sometimes also need to support clients using other agents — noticeable ones being Safari and mobile safari. For this we’ll be using standalone version of React Dev Tools and connect it remotely:</p><p><img loading=lazy src=images/15.png#layoutTextWidth alt=image></p><p>To get standalone tools fetch it with yarn or npm and simply start:
<code>npm install -g react-devtools react-devtool</code></p><p>What you should get is a welcome screen with information about how to connect. For browsers it should be as easy as adding a script to your page <code>&lt;head></code> section:
<code>&lt;script src="[http://localhost:8097](http://localhost:8097)">&lt;/script></code></p><p>and reloading the page. This will open a web-socket connection from your browser to the app used for all communication between debugger/profiler and dev-tools.</p><p><img loading=lazy src=images/16.png#layoutTextWidth alt=image></p><p>Unfortunately it has to run before <em>ReactDOM</em> is loaded, so it cannot be added in dev-tools when page is already shown in your browser. Just make sure you remove it from the code before committing or maybe you already have a separate html template for development and production. Then just put it only in dev one.</p><p>After a few seconds your app should connect and you should be able to use the same tools as in Chrome extension, but within unsupported browsers.</p><p>This solution will also work just fine for iOS Simulator. For Android emulator/device you’ll need another step — connect phone using cable and proxy all requests to localhost from your device to host:
<code>adb reverse tcp:8097 tcp:8097</code></p><p>Unfortunately there’s no easy way to use it with real iOS device. Due to security considerations React Dev Tools listen only on localhost and there’s no equivalent for <code>adb reverse</code> for iOS.</p><h3 id=unexpected-renders-of-memoized-components>Unexpected renders of memoized components<a hidden class=anchor aria-hidden=true href=#unexpected-renders-of-memoized-components>#</a></h3><p><code>React.memo</code> is usually treated as a holy grail and universal tool to fix all your performance problems. But sometimes it simply doesn"t seem to work. Usually it"s due to misunderstanding of how it works or what is really passed into component props. Let"s try to investigate such case using React Profiler and what to look for when we suspect memoization is not working. Here"s our suspected component:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>SlowComponent</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>(({</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>onClick</span> <span class=p>})</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=p>[]</span>  
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>1000000</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nx>arr</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  <span class=p>}</span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span><span class=nx>I</span><span class=err>&#34;</span><span class=nx>m</span> <span class=nx>slow</span> <span class=p>{</span><span class=nx>text</span><span class=p>}&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>onClick</span><span class=p>}/&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>It looks like it’s being correctly optimized. But let’s use it in a way that simply passes an inline function as a <code>onChange</code> parameter. This will basically make out <code>React.memo</code> useless, but what we want to do is to check how will this error manifest itself in React Profiler.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>App</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>loadData</span> <span class=o>=</span> <span class=nx>id</span> <span class=o>=&gt;</span> <span class=p>({</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=s2>&#34;some&#34;</span> <span class=p>})</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>_</span><span class=p>,</span> <span class=nx>setDummy</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>()</span><span class=sb>``</span><span class=k>return</span> <span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>className</span><span class=o>=</span><span class=s>&#34;App&#34;</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=nx>setDummy</span><span class=p>(</span><span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>())}&gt;</span><span class=nx>Render</span><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>SlowComponent</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=nx>loadData</span><span class=p>(</span><span class=s2>&#34;dummy&#34;</span><span class=p>)}</span> <span class=p>/&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To investigate problem like this, we need to have at least 2 renders of parent component without any changes in data passed to <code>SlowComponent</code>. In this example it"s actually easy. We"ll just press a button few times and it should re-render the <code>App</code> component. The only prop we pass in is this problematic inline function. Thanks to <code>React.memo</code> it should never re-render. The only moment this component should show up colored in the profiler is its initial mount. Let"s see how it actually behaves in the profiler:</p><p><img loading=lazy src=images/17.png#layoutTextWidth alt=image></p><p>We can see here, that it has been rendered on each button press, and it has taken quite a lot of time. Thanks to the popup you also see, that it’s due to <code>onClick</code> property changing. This is not what we wanted here, let"s fix this inline function and check how will profiler output look like afterwards. Wrapping it in a simple <code>useCallback</code> should be enough here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>App</span> <span class=o>=</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>loadData</span> <span class=o>=</span> <span class=nx>id</span> <span class=o>=&gt;</span> <span class=p>({</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=s2>&#34;some&#34;</span> <span class=p>})</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>_</span><span class=p>,</span> <span class=nx>setDummy</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>()</span><span class=sb>``</span><span class=k>return</span> <span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>className</span><span class=o>=</span><span class=s>&#34;App&#34;</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=nx>setDummy</span><span class=p>(</span><span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>())}</span> <span class=p>/&gt;</span>  
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>SlowComponent</span>  
</span></span><span class=line><span class=cl>        <span class=na>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>React</span><span class=p>.</span><span class=nx>useCallback</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=nx>loadData</span><span class=p>(</span><span class=s2>&#34;dummy&#34;</span><span class=p>),</span> <span class=p>[])}</span>  
</span></span><span class=line><span class=cl>      <span class=p>/&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl>  <span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And here’s how profiling results look like:</p><p><img loading=lazy src=images/18.png#layoutTextWidth alt=image></p><p><code>SlowComponent</code> did not render anywhere except of initial mount. That"s the result we have expected and it is clearly shown in the profiler data. This example might be trivial, but when investigating performance of theoretically optimized components you"ll be able to easily see them re-rendering in the profiler. Hovering on the component will also show why it has rendered. With this information it should be fairly easy to fix.</p><h4 id=using-update-highlights-to-find-unneeded-renders>Using update highlights to find unneeded renders<a hidden class=anchor aria-hidden=true href=#using-update-highlights-to-find-unneeded-renders>#</a></h4><p>There’s one more quick way to pinpoint components like that. It’s not really a profiler feature, but React Developer Tools have also an option to mark all rendered components with color borders. It’s especially useful to track forms re-renders. Often we’ll see some undesired renders when we were hoping that only single input was updated. Let’s enable the option now and check how it looks like.</p><p><img loading=lazy src=images/19.png#layoutTextWidth alt=image></p><p>In the screen below we can see a 3 input form. We’re editing first text input with “Highlight updates when components render” option enabled:</p><p><img loading=lazy src=images/20.png#layoutTextWidth alt=image></p><p>As you can see, on each character we put into the “What’s your name?” box, we have a render on all inputs and parent component. Parent re-rendering is probably fine, as it’s the place where we keep the state for the form. But all other inputs are not really related to the change, so we can optimize it.</p><p>In this particular case it might be an overkill to do it just for 2 inputs. But, especially when working with redux you might see some updates that are totally unexpected. Enabling “Highlight updates when components render” can be the only thing that you need to find performance issues then. It might be worth to enable it from time to time and play around with your app. You might be surprised how many unneeded renders are there.</p></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on x" href="https://x.com/intent/tweet/?text=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d&amp;url=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f&amp;title=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d&amp;summary=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d&amp;source=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f&title=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on whatsapp" href="https://api.whatsapp.com/send?text=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d%20-%20https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on telegram" href="https://telegram.me/share/url?text=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d&amp;url=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Investigate poor performance React components with “React Profiler” on ycombinator" href="https://news.ycombinator.com/submitlink?t=Investigate%20poor%20performance%20React%20components%20with%20%e2%80%9cReact%20Profiler%e2%80%9d&u=https%3a%2f%2fmarekpiechut.github.io%2fpost%2f2021-06-30_investigate-poor-performance-react-components-with-react-profiler%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© 2024 - Marek Piechut</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>